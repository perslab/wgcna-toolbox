---
title: 'Robust WGCNA - plotting'
author: "Jon Thompson, Pers lab"
date: "`r Sys.time()`" 
output:
  html_notebook: 
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
---

# Setup

## Set variables and constants 
```{r}
options(stringsAsFactors = F)

#project_dir = "/projects/jonatan/tmp-rwgcna-tests/mousebrain-top10-3/"
#data_prefix = "mousebrain-top10-3"
project_dir = "/projects/jonatan/tmp-rwgcna-tests/maca_top29_BMI_2/"
data_prefix = "maca_top29_BMI_2"

project_dir = "/projects/jonatan/tmp-rwgcna-tests/campbell_3/"
data_prefix = "campbell_3"


p.val.threshold = 5e-2
flag_date = substr(gsub("-","",as.character(Sys.Date())),3,1000)

```

```{r}
tables_dir <- paste0(project_dir, "tables/") 
log_dir <- paste0(project_dir, "log/") 
RObjects_dir <- paste0(project_dir, "RObjects/") 
plots_dir <- paste0(project_dir, "plots/")
```

## Load libraries 

```{r}

suppressPackageStartupMessages(library(reshape))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(WGCNA))
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(corrplot))
suppressPackageStartupMessages(library(RColorBrewer))


#suppressPackageStartupMessages(library(clusterProfiler))

```

## Load functions and constants

```{r}
source(file = "/projects/jonatan/functions-src/functions_v2.3_dev1.R")
```

# Load session image

```{r}
session_image_path <- dir(pattern = "final_session_image", path = RObjects_dir, full.names = T)
load(session_image_path)
```

## Plotting

### Plot modules on permuted data

```{r}

# TODO: retrieve code from leftovers

```

### Plot module assignment resulting from different parameters

```{r}

# Status: OK
# Pre-PPI - all different parameters, ordered by n genes assigned post PPI filter
invisible(mapply(function(a,b,c,d) plotDendro_for_vec(list_colors=a,
                                                        geneTree = b,
                                                        list_labels = c,
                                                        subsetName = d,
                                                        title = "Module params (pre-PPI), order: n assigned genes, pre-PPI filter",
                                                        flag_file = "modules_diffParams_ranked_pre_PPI"),
                 a = list_list_colors_ok_matched_order,
                 b = list_geneTree_ok,
                 c = list_list_plot_label_ok_order,
                 d = sNames_ok, 
                 SIMPLIFY = F))

# Post-PPI - all different parameters, ordered by n genes assigned post PPI filter
invisible(mapply(function(a,b,c,d) plotDendro_for_vec(list_colors=a,
                                                        geneTree = b,
                                                        list_labels = c,
                                                        subsetName = d,
                                                        title = "Module params (PPI), order: n assigned genes, post-PPI filter",
                                                        flag_file = "modules_diffParams_ranked_post_PPI"),
                 a = list_list_colors_PPI_order,
                 b = list_geneTree_ok,
                 c = list_list_plot_label_ok_order,
                 d = sNames_ok, 
                 SIMPLIFY = F))

```

```{r}

# TODO: Update for just original and post-PPI
# Plot different parameter module assignments: original, post-PPI, post-MAGMA, post- metadata correlation filter

list_filter_labels = c("Original modules", "post-PPI filter", "post-MAGMA filter", "post-metadata corr filter")
list_list_cols_tmp <- list(list_colors_uniq, list_colors_PPI_uniq, list_colors_gwas, list_colors_meta)

for (i in 2:length(list_list_cols_tmp)) {
  list_cols_tmp <- lapply(list_colors, function(x)  rep("grey", length(x))) 
  names(list_cols_tmp) <- names(list_colors) # create a list of vectors of 'grey', each named by celltype
  list_cols_tmp[names(list_colors) %in% names(list_list_cols_tmp[[i]])] <- list_list_cols_tmp[[i]]
  list_list_cols_tmp[[i]] <- list_cols_tmp
}

names(list_list_cols_tmp) <- list_filter_labels

list_list_cols_tmp_by_celltype <- vector(mode = "list", length=length(list_colors)) # 

for (i in 1:length(list_colors)) {
  for (j in 1:length(list_list_cols_tmp)) {
    list_list_cols_tmp_by_celltype[[i]][[j]] <- list_list_cols_tmp[[j]][[i]]
  }
  names(list_list_cols_tmp_by_celltype[[i]]) <- list_filter_labels
}
names(list_list_cols_tmp_by_celltype) <- names(list_colors)

invisible(mapply(function(a,b,c) plotDendro_for_vec(list_colors=a,
                                                        geneTree = b,
                                                        list_labels = list_filter_labels,
                                                        subsetName = c,
                                                        title = "Module params at different stages of filtering",
                                                        flag_file = "modules_filter_stages"),
                 a = list_list_cols_tmp_by_celltype,
                 b = list_geneTree_ok,
                 c = sNames_ok, 
                 SIMPLIFY = F))

```

## Plot MAGMA GWAS enrichment fdr-values


```{r}


kME_pan_B <-  read.csv("/projects/jonatan/tmp-rwgcna-tests/maca_top29_BMI_2/tables/maca_top29_BMI_2_Pancreas.type.B.pancreatic.cell_kMEs_meta_180718.csv", header = T)
kME_mus_T <-  read.csv("/projects/jonatan/tmp-rwgcna-tests/maca_top29_BMI_2/tables/maca_top29_BMI_2_Muscle.T.cell_kMEs_meta_180718.csv")

mapping_orthology = read.csv(gzfile(mapping_hs_mm_filepath),sep="\t",header=T, stringsAsFactors = F)
rownames(kME_pan_B) <- kME_pan_B$genes
rownames(kME_mus_T) <- kME_mus_T$genes
kME_pan_B <- mapMMtoHs(modulekM = kME_pan_B, log_dir = "/projects/jonatan/", flag_date = "180719", data_prefix = "nada", mapping_orthology = mapping_orthology)
kME_mus_T <- mapMMtoHs(modulekM = kME_mus_T, log_dir = "/projects/jonatan/", flag_date = "180719", data_prefix = "nada", mapping_orthology = mapping_orthology)

```

```{r}
magma_gwas_dir = "/projects/jonatan/tmp-bmi-brain/data/magma/BMI-brain/PT_added_gwas/"
d = dir(path=magma_gwas_dir, pattern="[.]genes.out", recursive = T)
gwas = vector(mode="list")
for(i in 1:length(d)) {
  gwas[[i]] = read.table(paste(magma_gwas_dir, d[[i]], sep=""),head=T, check.names = FALSE)
}
names(gwas) = gsub(".genes.out", "", d)
names(gwas)
# gwas

# gwas <- read.table("/projects/jonatan/tmp-bmi-brain/data/magma/BMI-brain/PT_added_gwas/EA3_Lee2018.genes.out", head=T, check.names = FALSE)


mapping_hs_entrez2ensembl_filepath = "/projects/tp/tmp-bmi-brain/data/mapping/gene_annotation_hsapiens.txt.gz"
mapping_hs_entrez2ensembl = read.csv(gzfile(mapping_hs_entrez2ensembl_filepath),sep="\t",header=T, stringsAsFactors = F)
    

# Remap from human Entrez to human Ensembl gene IDs
for (i in 1:length(gwas)) {
    idx = match(gwas[[i]]$GENE, mapping_hs_entrez2ensembl$entrezgene)
    mapping = data.frame(entrez=gwas[[i]]$GENE, ensembl=mapping_hs_entrez2ensembl$ensembl_gene_id[idx])
    gwas[[i]]$gene_name = mapping$ensembl
  }

# control arguments
j <- "EA3_Lee2018"

### cyan4 - pancratic beta
# modulekM <- kME_pan_B
# col <- "cyan4" # highly significant, 7e-14
#col <- "mintcream" # highly significant
# 4000 genes overlap

### snow1 - muscleT
modulekM <- kME_mus_T
col <- "snow1" # ns
# 2200 genes overlap

genes = intersect(rownames(modulekM),gwas[[j]]$gene_name)
length(genes)
x = -log10(gwas[[j]]$P[match(genes, gwas[[j]]$gene_name)])
x = gwas[[j]]$P[match(genes, gwas[[j]]$gene_name)]
y = modulekM[match(genes,rownames(modulekM)), col]

cor = cor.test(x,y,method="spearman", exact=F)
cor
cor.cyan
cor.snow

# cor.test(rank(x),rank(y))

qplot(rank(x),rank(y))
# q.snow <- qplot(x,y)
# q.cyan <- qplot(x,y)
q.snow
q.cyan
```

```{r}

magma.p.fdr.log.path <- dir(path = tables_dir, pattern = "magma.fdr.log.sig", full.names = T, recursive = F)
magma.p.fdr.log <- read.csv(file=magma.p.fdr.log.path, header=T, quote="") 


dat <- magma.p.fdr.log[,-grep("celltype", colnames(magma.p.fdr.log))]

p=ggplot(melt(dat, value.name="value"), aes(x=variable, y=value, fill = module)) + 
    geom_bar(stat="identity",position=position_dodge(),color= "black") +
    scale_fill_manual(values=plottable_colors(dat$module)) + theme_classic() +
    geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
    theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
  
ggsave(p, filename = paste0(plots_dir, data_prefix, "_magma_PT_log", flag_date, ".pdf") ,width=45,height=12)


# Filtered for only t1d/t2d/BMI gwas 
magma.p.fdr.log.sig <- magma.p.fdr.log[, grep("module|celltype|BMI|scz|t1d|t2d", colnames(magma.p.fdr.log), ignore.case = T)]
# filtered for 
magma.p.fdr.log.sig <- magma.p.fdr.log.sig[apply(magma.p.fdr.log.sig[,-grep("module|celltype", colnames(magma.p.fdr.log.sig))], FUN = function(x) max(x) > -log10(p.val.threshold), MARGIN=1),]


dat2 <- magma.p.fdr.log.sig[,-grep("celltype", colnames(magma.p.fdr.log.sig))]

p=ggplot(melt(dat2, value.name="value"), aes(x=variable, y=value, fill = module)) + 
    geom_bar(stat="identity",position=position_dodge(),color= "black") +
    scale_fill_manual(values=plottable_colors(dat2$module)) + theme_classic() +
    geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
    theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
  
ggsave(p, filename = paste0(plots_dir, data_prefix, "_magma_signif_", flag_date, ".pdf") ,width=45,height=12)

#   
# # filtered for metadata correlations
# p=ggplot(melt(dat_gwas_fdr_meta, value.name="value"),aes(x=variable,y=value, fill = module)) + 
#   geom_bar(stat="identity",position=position_dodge(),color= "black") +
#   scale_fill_manual(values=dat_gwas_fdr_meta$module) + theme_classic() +
#   geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
#   theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
#   
#  ggsave(p, filename = paste0(plots_dir, data_prefix, "_", "_magma_modules_gwas_signif_", flag_date, ".pdf") ,width=45,height=12)
```

## Plot rare variants, mendelian genes

```{r}

# TODO: Update for GSEA

rareVariants.p.fdr.log.path <- dir(path = tables_dir, pattern = "mendelian_rareVariants_fdr_log", full.names = T, recursive = F)
rareVariants.p.fdr.log <- read.csv(file=rareVariants.p.fdr.log.path, header=T, quote="") 

# all
dat1 <- rareVariants.p.fdr.log[,-grep("celltype", colnames(rareVariants.p.fdr.log))]
p1=ggplot(melt(dat1, value.name="value"), aes(x=variable, y=value, fill = module)) + 
    geom_bar(stat="identity",position=position_dodge(),color= "black") +
    scale_fill_manual(values=plottable_colors(dat1$module)) + theme_classic() +
    geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
    theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
  
ggsave(p1, filename = paste0(plots_dir, data_prefix,  "_rareVariants_", flag_date, ".pdf") ,width=45,height=12)

# only significant
rareVariants.p.fdr.log.sig <- rareVariants.p.fdr.log[apply(rareVariants.p.fdr.log[,-grep("module|celltype", colnames(rareVariants.p.fdr.log))], FUN = function(x) max(x) > -log10(p.val.threshold), MARGIN=1),]

dat2 <- rareVariants.p.fdr.log.sig[,-grep("celltype", colnames(rareVariants.p.fdr.log.sig))]
p2=ggplot(melt(dat2, value.name="value"), aes(x=variable, y=value, fill = module)) + 
    geom_bar(stat="identity",position=position_dodge(),color= "black") +
    scale_fill_manual(values=plottable_colors(dat2$module)) + theme_classic() +
    geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
    theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
  
ggsave(p2, filename = paste0(plots_dir, data_prefix, "_", "_rareVariants_signif_", flag_date, ".pdf") ,width=45,height=12)

```

#### Plot cell x eigengene embedding matrix

```{r}
# TODO: update for generalised kM
cellModEmbed_path <- dir(path = tables_dir, pattern="cellModEmbed", full.names = T, recursive = F, ignore.case = T)
cellModEmbed_mat <- read.csv(file = cellModEmbed_path, header = T, quote = "")

# Take rownames from column, then delete
rownames(cellModEmbed_mat) <- cellModEmbed_mat[,1]
cellModEmbed_mat[,1] <- NULL

#colnames(cellModEmbed_mat) <- gsub("^X", "", colnames(cellModEmbed_mat), ignore.case = F)
scale_data <- load_obj(f=sprintf("%s%s_scale_regr_data_ensembl_%s.RData", scratch_dir, data_prefix, flag_date))

# scale_data_path <- dir(path = scratch_dir, pattern = "scale_regr_data_ensembl", full.names = T)
# scale_data <- load_obj(scale_data_path) 

#seurat_obj <- SetAllIdent(seurat_obj, id = "ClusterName")
ident <- load_obj(f=sprintf("%s%s_ident_%s.RData", RObjects_dir, data_prefix, flag_date))

```

```{r}
# Order cells by celltype
cellModEmbed_mat <- cellModEmbed_mat[order(ident, decreasing=T), ] 

# To bring out mid-range expression differences in plot, take sqrt of values (first make positive, then sqrt, then restore original sign)

cellModEmbed_mat %>% '*'(sign(.)) %>% sqrt(.) %>% '*'(sign(cellModEmbed_mat)) -> cellModEmbed_mat_sqrt

# make row annotation: random colors for celltypes
colors_uniq <- gsub("\\d", "", colors()) %>% unique
htra_colors <- sample(colors_uniq, size=length(unique(ident)), replace=F) 
names(htra_colors) <- sort(unique(ident), decreasing=T)

htra<-rowAnnotation(cellcluster = sort(ident, decreasing=T),
                    annotation_legend_param = list(cellcluster = list(nrow = 7, title = "Cell cluster", title_position = "topcenter")),
                    col=list(cellcluster = htra_colors),
                    width = unit(5, "mm"))

ht1 <- Heatmap(cellModEmbed_mat[,], 
             cluster_rows = F,
             #row_order = ,
             cluster_columns = T, 
             #show_row_dend = F, 
             show_column_dend = F, 
             show_heatmap_legend = T, 
             show_row_names = F, 
             show_column_names = T,
             heatmap_legend_param = list(title = "Expression"))
             #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
#pdf(sprintf("%s%s_cellModEmbed_cellOrder_%s.pdf", plots_dir, data_prefix, flag_date ),h=nrow(cellModEmbed_mat) %/% 1000, w=ncol(cellModEmbed_mat) %/% 2)
draw(ht1+htra)
#dev.off()
  
# with square root transform to bring out mid-range expression differences
ht2 <- Heatmap(cellModEmbed_mat_sqrt[,], 
             cluster_rows = F,
             #row_order = ,
             cluster_columns = T, 
             #show_row_dend = F, 
             show_column_dend = F, 
             show_heatmap_legend = T, 
             show_row_names = F, 
             show_column_names = T,
             heatmap_legend_param = list(title = "Expression"))
             #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_cellModEmbed_cellOrder_sqrt%s.pdf", plots_dir, data_prefix, flag_date ),h=nrow(cellModEmbed_mat) %/% 1000, w=ncol(cellModEmbed_mat) %/% 2)
draw(ht2+htra)
dev.off()
  

# With clustering rows
ht3 <- Heatmap(cellModEmbed_mat[,], 
               cluster_rows = T,
               #row_order = NULL,
               cluster_columns = T, 
               #show_row_dend = F, 
               show_column_dend = F, 
               show_heatmap_legend = T, 
               show_row_names = F, 
               show_column_names = T,
               heatmap_legend_param = list(title = "Expression"))
               #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_cellModEmbed_cellCluster_%s.pdf", plots_dir, data_prefix, flag_date ),h=nrow(cellModEmbed_mat) %/% 1000, w=ncol(cellModEmbed_mat) %/% 2)
draw(ht3+htra)
dev.off()

# With clustering rows, sqrt
ht4 <- Heatmap(cellModEmbed_mat_sqrt[,], 
               cluster_rows = T,
               #row_order = NULL,
               cluster_columns = T, 
               #show_row_dend = F, 
               show_column_dend = F, 
               show_heatmap_legend = T, 
               show_row_names = F, 
               show_column_names = T,
               heatmap_legend_param = list(title = "Expression"))
               #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_cellModEmbed_sqrt_cellCluster_%s.pdf", plots_dir, data_prefix, flag_date ),h=nrow(cellModEmbed_mat) %/% 1000, w=ncol(cellModEmbed_mat) %/% 2)
draw(ht4+htra)
dev.off()


# Without clustering rows nor columns
ht5 <- Heatmap(cellModEmbed_mat[,], 
               cluster_rows = F,
               #row_order = NULL,
               cluster_columns = F, 
               #show_row_dend = F, 
               #show_column_dend = F, 
               show_heatmap_legend = T, 
               show_row_names = F, 
               show_column_names = T,
               heatmap_legend_param = list(title = "Expression"))
               #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_cellModEmbed_RowColOrder_%s.pdf", plots_dir, data_prefix, flag_date ),h=nrow(cellModEmbed_mat) %/% 1000, w=ncol(cellModEmbed_mat) %/% 2)
draw(ht5+htra)
dev.off()  


# Without clustering rows nor columns, sqrt
ht6 <- Heatmap(cellModEmbed_mat_sqrt[,], 
               cluster_rows = F,
               #row_order = NULL,
               cluster_columns = F, 
               #show_row_dend = F, 
               #show_column_dend = F, 
               show_heatmap_legend = T, 
               show_row_names = F, 
               show_column_names = T,
               heatmap_legend_param = list(title = "Expression"))
               #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_cellModEmbed_sqrt_RowColOrder_%s.pdf", plots_dir, data_prefix, flag_date ),h=nrow(cellModEmbed_mat) %/% 1000, w=ncol(cellModEmbed_mat) %/% 2)
draw(ht6+htra)
dev.off()  
```

### Plot module-metadata correlation matrices

```{r}
#TODO: Incorporate into eigen plot (or simply replace with another form)
 

if (!is.null(metadata)) {
  for (cell in names(list_eigen_metadata_corr_rho)){
    pdf(sprintf("%s%s_%s_mod_corr_metadata_%s.pdf", plots_dir, data_prefix, cell, flag_date), w=15, h=8) # TODO: adapt this dynamically
    corrplot(corr = as.matrix(list_eigen_metadata_corr_rho[[cell]]),
             add = F,
             addCoef.col = "black",
             number.digits = 2L,
             number.cex = 2,
             tl.cex = 2,
             cl.cex = 1,
             method = "color",
             col=colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu")), bias=1)(200),
             is.corr=T,
             #order = "hclust",
             #hclust.method = hclustMethod,
             title=NULL,#sprintf("%s eigenvector - metadata correlations", data_prefix),
             #addCoef.col = F,
             p.mat = t(as.matrix(list_eigen_metadata_corr_fdr[[cell]])),
             sig.level = 5e-2)

    dev.off()
  }
}

```

### Plot t-SNE of cell clusters
(assumes that the TSNE reduction has been computed)
```{r}

seurat_obj <- load_obj(f=sprintf("%sseurat_obj_ensembl.RData",RObjects_dir))
if (is.null(seurat_obj@dr$pca)) seurat_obj <- RunPCA(object=seurat_obj, pc.genes = var.genes, pcs.compute = 20, do.print = F)
if (is.null(seurat_obj@dr$tsne)) seurat_obj <- RunTSNE(object = seurat_obj, reduction.use = PCA, dims.use = 1:(min(20, nPC_seurat)))
TSNEPlot(seurat_obj, do.label = T, label.size = 8)
#TSNEPlot(seurat_obj, colors.use = htra_colors, do.label = T)
ggsave(paste0(plots_dir,data_prefix, "_TSNE_cell_clusters_", flag_date, ".pdf"),w=12, h=10)

```

## Plot metadata in cells on t-SNE featureplots

```{r}

for (j in names(seurat_obj@meta.data)) seurat_obj@meta.data[j] <- NULL
seurat_obj <- AddMetaData(seurat_obj, as.data.frame(metadata))

for (feat in names(seurat_obj@meta.data)) {
  color_to_plot <- "blue4"
  FeaturePlot(seurat_obj, features.plot = feat, cols.use = c("grey85", color_to_plot))#, min.cutoff = c("q25"))
  ggsave(paste0(plots_dir,data_prefix,"_featplot_", feat, flag_date, ".pdf"),w=12, h=10)
}

```

### Plot module eigengene expression on t-SNE featureplots 

```{r}

for (j in names(seurat_obj@meta.data)) seurat_obj@meta.data[j] <- NULL
seurat_obj <- AddMetaData(seurat_obj, cellModEmbed_mat[match(rownames(seurat_obj@meta.data), rownames(cellModEmbed_mat)),])

for (mod in names(seurat_obj@meta.data)) {
  color_to_plot <- "blue4"
  FeaturePlot(seurat_obj, features.plot = mod, cols.use = c("grey85", color_to_plot), min.cutoff = c("q25"))
  ggsave(paste0(plots_dir,flag_date,"_",data_prefix,"_featplot_mod_", mod, ".pdf"),w=12, h=10)
}

```

### Plot module-module correlations

```{r}

load(file=sprintf("%s%s_mod_mod_corr_files_%s", RObjects, data_prefix, flag_date))


# plot
  pdf(sprintf("%s%s_mod_corr%s.pdf", plots_dir, data_prefix, flag_date), width=ncol(cellModEmbed_mat) %/% 3,height=ncol(cellModEmbed_mat) %/% 3)
  
  corrplot(corr = mod_corr, 
           method = "color",
           col = colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu")), bias = 1)(200),
           diag = F,
           is.corr=T,
           #title=sprintf("%s module corr across subsets", data_prefix),
           order = "hclust",
           hclust.method = hclustMethod,
           addCoef.col = "black",
           tl.srt = 45,
           number.digits = 2L,
           number.cex = 0.5)
           #tl.cex = 2,
           #cl.cex = 1)
    
  invisible(dev.off())

```

# plot module clusters

```{r}

load(file=sprintf("%s%s_mod_mod_corr_files_%s", RObjects, data_prefix, flag_date))

pdf(sprintf("%s%s_module_cluster%s.pdf", plots_dir, data_prefix, flag_date),width=ncol(cellModEmbed_mat) %/% 3,height=ncol(cellModEmbed_mat) %/% 3)

plotDendroAndColors(dendro=mod_corr_dendro,
                    colors = mod_corr_clust,
                    addGuide=T,
                    dendroLabels=NULL, 
                    main="Module clustering across celltypes")
                    #cex.colorLabels=0.4)
#abline(h=1-moduleMergeCutHeight)
dev.off()
```


# Compute kMEs of the merged modules

```{r}
# TODO
```

# Compute rare variant and mendelian gene enrichment with the merged modules

```{r}
# TODO
```

# Compute MAGMA enrichment with the merged modules 

```{r}
# TODO
```

# 

```{r}

```

# Compute eigen_mat of the merged modules

```{r}
##########################################################################
#####################  MERGE CORRELATED MODULES ##########################
##########################################################################
# ARCHIVE

# Identify highly correlated modules
mod_corr_lt <- mod_corr
mod_corr_lt[!lower.tri(mod_corr, diag = F)] <- NA
idx_toMerge <- which(mod_corr_lt>(1-moduleMergeCutHeight), arr.ind = T)


# Merge highly correlated modules

modules_merged <- dat_BMI_fdr$module
list_module_BMI_merged <- list_module_BMI # this is a nested version of the above list
list_list_module_BMI_genes_merged  <- list_list_module_BMI_genes
list_colors_BMI_merged <- list_colors_BMI

if (nrow(idx_toMerge) > 0) {
  
  for (i in 1:nrow(idx_toMerge)) {
    
    message(paste0("Merging ", dat_BMI_fdr$module[idx_toMerge[i,1]], " with ", dat_BMI_fdr$module[idx_toMerge[i,2]], " - eigengene correlation is ", round(mod_corr[idx_toMerge[i,1],idx_toMerge[i,2]],2)))
    subset_from <- gsub("_.*", "", dat_BMI_fdr$module[idx_toMerge[i,1]])
    module_from <- gsub(".*_", "", dat_BMI_fdr$module[idx_toMerge[i,1]])
    subset_to <- gsub("_.*", "", dat_BMI_fdr$module[idx_toMerge[i,2]])
    module_to <- gsub(".*_", "", dat_BMI_fdr$module[idx_toMerge[i,2]])
    
    list_list_module_BMI_genes_merged[[subset_to]] [[module_to]] <- union(list_list_module_BMI_genes[[subset_to]] [[module_to]] , list_list_module_BMI_genes[[subset_from]][[module_from]])
    
    list_list_module_BMI_genes_merged[[subset_from]] [[module_from]] <- NULL
    
    
    list_colors_BMI_merged[[subset_from]] [ list_colors_BMI_merged[[subset_from]] == module_from] <- module_to 
    
    modules_merged[idx_toMerge[i,2]] <- paste0(dat_BMI_fdr$module[idx_toMerge[i,2]], "_", dat_BMI_fdr$module[idx_toMerge[i,1]])
    modules_merged[idx_toMerge[i,1]] <- NA
    
  }
  
  modules_merged <- modules_merged[!is.na(modules_merged)]
  
  # get a new vector of names of cell clusters with BMI enrichment after merging
  sNames_BMI <- unique(gsub("_.*", "", modules_merged))
  
  # Transform the vector of modules into a nested list, as before
  list_module_BMI <- vector(mode="list", length=length(sNames_BMI_merged))
  names(list_module_BMI) <- sNames_BMI
  
  for (name in sNames_BMI_merged) {
    idx <- grep(pattern = paste0(name, "_.*"), x = modules_merged)
    list_module_BMI[[name]] <- sapply(idx, function(j) gsub(".*_", "", modules_merged[j]), simplify = T)
  }
}


```

### Plot module presevation

```{r}

# TODO: move the calculation into the main script

suppressPackageStartupMessages(library(pheatmap))

# Check preservation of each set of colors in all celltypes (including itself)
module_preservation_celltypes <- sapply(list_colors, function(x) wrapModulePreservation(listDatExpr = list_datExpr_ok,
                                                                                                listColors = list(x))[['preservation']][['log.pBonf']],
                                                          simplify = T)

colnames(module_preservation_celltypes) = sNames_ok
rownames(module_preservation_celltypes) = paste(prefixes, names(unlist(list_colors, recursive = F, use.names = T)), sep="_")

# plot
pheatmap(mat = module_preservation_celltypes, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))[0:100],
         kmeans_k = NA,
         breaks = NA, 
         cluster_rows = F,
         cluster_cols = F,
         #clustering_method = hclustMethod,
         show_rownames = T,
         show_colnames = T,
         main = sprintf("%s_%s_%s", data_prefix, "module preservation across celltypes", flag_date),
         filename=sprintf("%s%s_%s_%s.pdf", plots_dir, data_prefix, "module_preservation", flag_date),
         width = length(list_datExpr_ok) %/% 2,
         height = length(unlist(list_colors, recursive = F)) %/% 4,
         silent = T)

### 180607_v1.8_dev2
#if (!is.null(STRINGdb_species)) {
module_PPI_preservation_celltypes <- sapply(list_colors_PPI, function(x) wrapModulePreservation(listDatExpr = list_datExpr_ok,
                                                                                              listColors = list(x))[['preservation']][['log.pBonf']],
                                        simplify = T)

colnames(module_PPI_preservation_celltypes) = sNames_ok
rownames(module_PPI_preservation_celltypes) = paste(prefixes, names(unlist(list_colors_PPI, recursive = F, use.names = T)), sep="_")

# plot
pheatmap(mat = module_PPI_preservation_celltypes, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))[0:100],
         kmeans_k = NA,
         breaks = NA, 
         cluster_rows = F,
         cluster_cols = F,
         #clustering_method = hclustMethod,
         show_rownames = T,
         show_colnames = T,
         main = sprintf("%s_%s_%s", data_prefix, "PPI-enriched modules: preservation across celltypes", flag_date),
         filename=sprintf("%s%s_%s_%s.pdf", plots_dir, data_prefix, "PPI_module_preservation", flag_date),
         width = length(list_datExpr_ok) %/% 2,
         height = length(unlist(list_colors_PPI, recursive = F)) %/% 4,
         silent = T)
#}
###
```

