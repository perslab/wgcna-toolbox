---
title: 'Robust WGCNA - plotting'
author: "Jon Thompson, Pers lab"
date: "`r Sys.time()`" 
output:
  html_notebook: 
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
---

# Setup

## Set variables and constants 
```{r}
options(stringsAsFactors = F)

project_dir = "/projects/jonatan/tmp-rwgcna-tests/mousebrain_top10_5/"
data_prefix = "mousebrain_top10"
run_prefix = "8"

p.val.threshold = 5e-2
flag_date = substr(gsub("-","",as.character(Sys.Date())),3,1000)

```

```{r}
tables_dir <- paste0(project_dir, "tables/") 
log_dir <- paste0(project_dir, "log/") 
RObjects_dir <- paste0(project_dir, "RObjects/") 
plots_dir <- paste0(project_dir, "plots/")
scratch_dir <- "/scratch/tmp-wgcna/"
```

## Load libraries 

```{r}

suppressPackageStartupMessages(library(reshape))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(WGCNA))
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(corrplot))
suppressPackageStartupMessages(library(RColorBrewer))


#suppressPackageStartupMessages(library(clusterProfiler))

```

## Load functions and constants

```{r}
networkType="signed"
source(file =  "/projects/jonatan/wgcna-src/wgcna-toolbox/rwgcna_params.R")
source(file = "/projects/jonatan/wgcna-src/wgcna-toolbox/rwgcna_functions.R")
```

# Load session image

```{r}
session_image_path <- dir(pattern = "final_session_image", path = RObjects_dir, full.names = T)
load(session_image_path)
```

## Retrieve run stats

```{r}
sumstats_run <- read.table(sprintf("%s/%s_%s_sumstats_run.tab", log_dir, data_prefix, run_prefix), sep = "\t", quote = "", header=T)
sumstats_celltype <- read.table(sprintf("%s/%s_%s_sumstats_celltype.tab", log_dir, data_prefix, run_prefix), sep = "\t", quote = "", header=T)
```

## Plotting

### Plot modules on permuted data

```{r}

# TODO: retrieve code from leftovers

```

### Plot module assignment resulting from different parameters

```{r}

# Status: OK
# Pre-PPI - all different parameters, ordered by n genes assigned post PPI filter
invisible(mapply(function(a,b,c,d) plotDendro_for_vec(list_colors=a,
                                                        geneTree = b,
                                                        list_labels = c,
                                                        subsetName = d,
                                                        title = "Module params (pre-PPI), order: n assigned genes, pre-PPI filter",
                                                        flag_file = "modules_diffParams_ranked_pre_PPI"),
                 a = list_list_colors_matched_ok_order,
                 b = list_geneTree_ok,
                 c = list_list_plot_label_ok_order,
                 d = sNames_ok, 
                 SIMPLIFY = F))

# Post-PPI - all different parameters, ordered by n genes assigned post PPI filter
invisible(mapply(function(a,b,c,d) plotDendro_for_vec(list_colors=a,
                                                        geneTree = b,
                                                        list_labels = c,
                                                        subsetName = d,
                                                        title = "Module params (PPI), order: n assigned genes, post-PPI filter",
                                                        flag_file = "modules_diffParams_ranked_post_PPI"),
                 a = list_list_colors_PPI_order,
                 b = list_geneTree_ok,
                 c = list_list_plot_label_ok_order,
                 d = sNames_ok, 
                 SIMPLIFY = F))

```

```{r}

# TODO: Update for just original and post-PPI
# Plot different parameter module assignments: original, post-PPI, post-MAGMA, post- metadata correlation filter

list_filter_labels = c("Original modules", "post-PPI filter", "post-MAGMA filter", "post-metadata corr filter")
list_list_cols_tmp <- list(list_colors_uniq, list_colors_PPI_uniq, list_colors_gwas, list_colors_meta)

for (i in 2:length(list_list_cols_tmp)) {
  list_cols_tmp <- lapply(list_colors, function(x)  rep("grey", length(x))) 
  names(list_cols_tmp) <- names(list_colors) # create a list of vectors of 'grey', each named by celltype
  list_cols_tmp[names(list_colors) %in% names(list_list_cols_tmp[[i]])] <- list_list_cols_tmp[[i]]
  list_list_cols_tmp[[i]] <- list_cols_tmp
}

names(list_list_cols_tmp) <- list_filter_labels

list_list_cols_tmp_by_celltype <- vector(mode = "list", length=length(list_colors)) # 

for (i in 1:length(list_colors)) {
  for (j in 1:length(list_list_cols_tmp)) {
    list_list_cols_tmp_by_celltype[[i]][[j]] <- list_list_cols_tmp[[j]][[i]]
  }
  names(list_list_cols_tmp_by_celltype[[i]]) <- list_filter_labels
}
names(list_list_cols_tmp_by_celltype) <- names(list_colors)

invisible(mapply(function(a,b,c) plotDendro_for_vec(list_colors=a,
                                                        geneTree = b,
                                                        list_labels = list_filter_labels,
                                                        subsetName = c,
                                                        title = "Module params at different stages of filtering",
                                                        flag_file = "modules_filter_stages"),
                 a = list_list_cols_tmp_by_celltype,
                 b = list_geneTree_ok,
                 c = sNames_ok, 
                 SIMPLIFY = F))

```

## Plot MAGMA GWAS enrichment fdr-values

```{r}

magma.p.fdr.log.path <- dir(path = tables_dir, pattern = "magma.fdr.log.sig", full.names = T, recursive = F)
magma.p.fdr.log <- read.csv(file=magma.p.fdr.log.path, header=T, quote="") 


dat <- magma.p.fdr.log[,-grep("celltype", colnames(magma.p.fdr.log))]

p=ggplot(melt(dat, value.name="value"), aes(x=variable, y=value, fill = module)) + 
    geom_bar(stat="identity",position=position_dodge(),color= "black") +
    scale_fill_manual(values=plottable_colors(dat$module)) + theme_classic() +
    geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
    theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
  
ggsave(p, filename = paste0(plots_dir, data_prefix, "_magma_log", flag_date, ".pdf") ,width=45,height=12)


# Filtered for only t1d/t2d/BMI gwas 
magma.p.fdr.log.sig <- magma.p.fdr.log[, grep("module|celltype|BMI|scz|t1d|t2d", colnames(magma.p.fdr.log), ignore.case = T)]
# filtered for 
magma.p.fdr.log.sig <- magma.p.fdr.log.sig[apply(magma.p.fdr.log.sig[,-grep("module|celltype", colnames(magma.p.fdr.log.sig))], FUN = function(x) max(x) > -log10(p.val.threshold), MARGIN=1),]


dat2 <- magma.p.fdr.log.sig[,-grep("celltype", colnames(magma.p.fdr.log.sig))]

p=ggplot(melt(dat2, value.name="value"), aes(x=variable, y=value, fill = module)) + 
    geom_bar(stat="identity",position=position_dodge(),color= "black") +
    scale_fill_manual(values=plottable_colors(dat2$module)) + theme_classic() +
    geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
    theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
  
ggsave(p, filename = paste0(plots_dir, data_prefix, "_magma_signif_", flag_date, ".pdf") ,width=45,height=12)

#   
# # filtered for metadata correlations
# p=ggplot(melt(dat_gwas_fdr_meta, value.name="value"),aes(x=variable,y=value, fill = module)) + 
#   geom_bar(stat="identity",position=position_dodge(),color= "black") +
#   scale_fill_manual(values=dat_gwas_fdr_meta$module) + theme_classic() +
#   geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
#   theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
#   
#  ggsave(p, filename = paste0(plots_dir, data_prefix, "_", "_magma_modules_gwas_signif_", flag_date, ".pdf") ,width=45,height=12)
```

## Plot rare variants, mendelian genes

```{r}

# TODO: Update for GSEA, doesn't work at present

rareVariants.p.fdr.log.path <- dir(path = tables_dir, pattern = "mendelian_rareVariants_fdr_log", full.names = T, recursive = F)
rareVariants.p.fdr.log <- read.csv(file=rareVariants.p.fdr.log.path, header=T, quote="") 

# all
dat1 <- rareVariants.p.fdr.log[,-grep("celltype", colnames(rareVariants.p.fdr.log))]
p1=ggplot(melt(dat1, value.name="value"), aes(x=variable, y=value, fill = module)) + 
    geom_bar(stat="identity",position=position_dodge(),color= "black") +
    scale_fill_manual(values=plottable_colors(dat1$module)) + theme_classic() +
    geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
    theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
  
ggsave(p1, filename = paste0(plots_dir, data_prefix,  "_rareVariants_", flag_date, ".pdf") ,width=45,height=12)

# only significant
rareVariants.p.fdr.log.sig <- rareVariants.p.fdr.log[apply(rareVariants.p.fdr.log[,-grep("module|celltype", colnames(rareVariants.p.fdr.log))], FUN = function(x) max(x) > -log10(p.val.threshold), MARGIN=1),]

dat2 <- rareVariants.p.fdr.log.sig[,-grep("celltype", colnames(rareVariants.p.fdr.log.sig))]
p2=ggplot(melt(dat2, value.name="value"), aes(x=variable, y=value, fill = module)) + 
    geom_bar(stat="identity",position=position_dodge(),color= "black") +
    scale_fill_manual(values=plottable_colors(dat2$module)) + theme_classic() +
    geom_abline(intercept=-log10(0.05),slope=0,lty=2) + labs(x="",y="log10(P.fdr)") +
    theme(axis.text.x=element_text(angle=50, size=10, hjust=1))
  
ggsave(p2, filename = paste0(plots_dir, data_prefix, "_", "_rareVariants_signif_", flag_date, ".pdf") ,width=45,height=12)

```

#### Load cell x eigengene embedding matrix

```{r}

# This should already be set if user loaded session image
fuzzyModMembership ="kME"

# Find cell module embedding matrix 
cellModEmbed_path <- dir(path = tables_dir, pattern="cellModEmbed", full.names = T, recursive = F, ignore.case = T)
cellModEmbed_path <- cellModEmbed_path[grep(fuzzyModMembership, cellModEmbed_path)]
cellModEmbed_mat <- read.csv(file = cellModEmbed_path, header = T, quote = "")

# Take rownames from column, then delete
rownames(cellModEmbed_mat) <- cellModEmbed_mat[,1]
cellModEmbed_mat[,1] <- NULL

#colnames(cellModEmbed_mat) <- gsub("^X", "", colnames(cellModEmbed_mat), ignore.case = F)
#scale_data <- load_obj(f=sprintf("%s%s_scale_regr_data_ensembl_%s.RData", scratch_dir, data_prefix, flag_date))

# scale_data_path <- dir(path = scratch_dir, pattern = "scale_regr_data_ensembl", full.names = T)
# scale_data <- load_obj(scale_data_path) 

#seurat_obj <- SetAllIdent(seurat_obj, id = "ClusterName")
ident_path <- dir(path=scratch_dir, pattern=paste0(data_prefix, "_ident"), full.names=T)
ident <- load_obj(f=ident_path)

```

#### Plot cell x eigengene embedding matrix

```{r}

# Order cells by celltype
cellModEmbed_mat <- cellModEmbed_mat[order(ident, decreasing=T), ] 

# To bring out mid-range expression differences in plot, take sqrt of values (first make positive, then sqrt, then restore original sign)

cellModEmbed_mat %>% '*'(sign(.)) %>% sqrt(.) %>% '*'(sign(cellModEmbed_mat)) -> cellModEmbed_mat_sqrt

# make row annotation: random colors for celltypes
colors_uniq <- gsub("\\d", "", colors()) %>% unique
htra_colors <- sample(colors_uniq, size=length(unique(ident)), replace=F) 
names(htra_colors) <- sort(unique(ident), decreasing=T)

htra<-rowAnnotation(cellcluster = sort(ident, decreasing=T),
                    annotation_legend_param = list(cellcluster = list(nrow = 7, title = "Cell cluster", title_position = "topcenter")),
                    col=list(cellcluster = htra_colors),
                    width = unit(5, "mm"))

ht1 <- Heatmap(cellModEmbed_mat[,], 
             cluster_rows = F,
             #row_order = ,
             cluster_columns = T, 
             #show_row_dend = F, 
             show_column_dend = F, 
             show_heatmap_legend = T, 
             show_row_names = F, 
             show_column_names = T,
             heatmap_legend_param = list(title = "Expression"))
             #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_%s_cellModEmbed_cellOrder_%s.pdf", plots_dir, data_prefix, fuzzyModMembership, flag_date ),h=max(10, nrow(cellModEmbed_mat) %/% 1000), w=max(8, ncol(cellModEmbed_mat) %/% 2))
draw(ht1+htra)
dev.off()
  
# with square root transform to bring out mid-range expression differences
ht2 <- Heatmap(cellModEmbed_mat_sqrt[,], 
             cluster_rows = F,
             #row_order = ,
             cluster_columns = T, 
             #show_row_dend = F, 
             show_column_dend = F, 
             show_heatmap_legend = T, 
             show_row_names = F, 
             show_column_names = T,
             heatmap_legend_param = list(title = "Expression"))
             #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_%s_cellModEmbed_cellOrder_sqrt%s.pdf", plots_dir, data_prefix, fuzzyModMembership, flag_date ),h=max(10, nrow(cellModEmbed_mat) %/% 1000), w=max(8, ncol(cellModEmbed_mat) %/% 2))
draw(ht2+htra)
dev.off()
  

# With clustering rows
ht3 <- Heatmap(cellModEmbed_mat[,], 
               cluster_rows = T,
               #row_order = NULL,
               cluster_columns = T, 
               #show_row_dend = F, 
               show_column_dend = F, 
               show_heatmap_legend = T, 
               show_row_names = F, 
               show_column_names = T,
               heatmap_legend_param = list(title = "Expression"))
               #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_%s_cellModEmbed_cellCluster_%s.pdf", plots_dir, data_prefix, fuzzyModMembership,  flag_date ),h=max(10, nrow(cellModEmbed_mat) %/% 1000), w=max(8, ncol(cellModEmbed_mat) %/% 2))
draw(ht3+htra)
dev.off()

# With clustering rows, sqrt
ht4 <- Heatmap(cellModEmbed_mat_sqrt[,], 
               cluster_rows = T,
               #row_order = NULL,
               cluster_columns = T, 
               #show_row_dend = F, 
               show_column_dend = F, 
               show_heatmap_legend = T, 
               show_row_names = F, 
               show_column_names = T,
               heatmap_legend_param = list(title = "Expression"))
               #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_%s_cellModEmbed_sqrt_cellCluster_%s.pdf", plots_dir, data_prefix, fuzzyModMembership, flag_date ),h=max(10, nrow(cellModEmbed_mat) %/% 1000), w=max(8, ncol(cellModEmbed_mat) %/% 2))
draw(ht4+htra)
dev.off()


# Without clustering rows nor columns
ht5 <- Heatmap(cellModEmbed_mat[,], 
               cluster_rows = F,
               #row_order = NULL,
               cluster_columns = F, 
               #show_row_dend = F, 
               #show_column_dend = F, 
               show_heatmap_legend = T, 
               show_row_names = F, 
               show_column_names = T,
               heatmap_legend_param = list(title = "Expression"))
               #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_%s_cellModEmbed_RowColOrder_%s.pdf", plots_dir, data_prefix, fuzzyModMembership,  flag_date ),h=max(10, nrow(cellModEmbed_mat) %/% 1000), w=max(8, ncol(cellModEmbed_mat) %/% 2))
draw(ht5+htra)
dev.off()  


# Without clustering rows nor columns, sqrt
ht6 <- Heatmap(cellModEmbed_mat_sqrt[,], 
               cluster_rows = F,
               #row_order = NULL,
               cluster_columns = F, 
               #show_row_dend = F, 
               #show_column_dend = F, 
               show_heatmap_legend = T, 
               show_row_names = F, 
               show_column_names = T,
               heatmap_legend_param = list(title = "Expression"))
               #top_annotation = eval(parse(text = paste0("list_htca_fdr", "[[", 1:length(list_htca_fdr),"]]"))))
pdf(sprintf("%s%s_%s_cellModEmbed_sqrt_RowColOrder_%s.pdf", plots_dir, data_prefix, fuzzyModMembership, flag_date ),h=max(10, nrow(cellModEmbed_mat) %/% 1000), w=max(8, ncol(cellModEmbed_mat) %/% 2))
draw(ht6+htra)
dev.off()  
```

### Compute module-module correlations

```{r, fig.height=10, fig.width=10}

##########################################################################
########### CORRELATE MODULE EXPRESSION PROFILES ACROSS CELLTYPES ########
##########################################################################

mod_corr <- WGCNA::cor(x=cellModEmbed_mat, method=c("pearson"), verbose=verbose)

# Cluster modules across celltypes using the Pearson correlation between module cell embeddings
corr_pos <- mod_corr
corr_pos[corr_pos<0] <- 0
corr_dist <- as.dist(m = (1-corr_pos), diag = F, upper = F) # convert to (1-corr) distance matrix
corr_dendro <- hclust(d = corr_dist, method = "average")

# use a simple cut to determine clusters
corr_clust = cutreeStatic(dendro = corr_dendro, cutHeight = moduleMergeCutHeight, minSize=1)
names(corr_clust) =  corr_dendro$labels
names(corr_clust) <- gsub(" |\\.","_",names(corr_clust)) 

```

### Plot module-module correlation matrix across cell clusters

```{r}

pdf(sprintf("%s%s_mod_corr_%s.pdf", plots_dir, data_prefix, flag_date), width=max(8,ncol(cellModEmbed_mat) %/% 3),height=max(8,ncol(cellModEmbed_mat) %/% 3))

corrplot(corr = mod_corr, 
         method = "color",
         col = colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu")), bias = 1)(200),
         diag = F,
         is.corr=T,
         #title=sprintf("%s module corr across subsets", data_prefix),
         order = "hclust",
         hclust.method = hclustMethod,
         addCoef.col = "black",
         tl.srt = 45,
         number.digits = 2L,
         number.cex = 0.5)
         #tl.cex = 2,
         #cl.cex = 1)
  
invisible(dev.off())

```

### plot hierarchical clustering dendrogram of modules found across celltype

```{r, fig.height=10, fig.width=10}

pdf(sprintf("%s%s_module_cluster_%s.pdf", plots_dir, data_prefix, flag_date),width=max(8,ncol(cellModEmbed_mat) %/% 3),height=max(8, ncol(cellModEmbed_mat) %/% 3))

plotDendroAndColors(dendro=corr_dendro,
                    colors = corr_clust,
                    addGuide=T,
                    dendroLabels=NULL, 
                    main="Module clustering across celltypes")
                    #cex.colorLabels=0.4)
#abline(h=1-moduleMergeCutHeight)
dev.off()
```

# Merge close modules - genelists

```{r}
genelist_path <- dir(pattern = paste0(data_prefix, "_list_list_module_genes"), path = RObjects_dir, full.names = T)
list_list_module_genes <- load_obj(f=genelist_path)
  
######################################################################
########################## MERGE GENE LISTS ##########################
######################################################################

# First make a one-layer list where the celltype is in the name
list_module_genes <- unlist(list_list_module_genes, use.names = T, recursive=F)
names(list_module_genes) <- gsub(pattern = " ", replacement = "_", names(list_module_genes))
names(list_module_genes) <- gsub(pattern = "\\.", replacement = "__", names(list_module_genes))

# Merge the module gene lists
list_module_genes_merge <- lapply(unique(corr_clust), function(x) Reduce(f=union, 
                                                                         list_module_genes[names(list_module_genes) %in% names(corr_clust)[corr_clust==x]]))
tmp_cols <- paste0(gsub("\\w.+__", "", names(list_module_genes)),".")
tmp_cellTypes <- paste0(gsub("__\\w+", "", names(list_module_genes)), ".")

tmp_cellTypes_merge <- sapply(unique(corr_clust), function(x) Reduce(f=paste0, tmp_cellTypes[names(list_module_genes) %in% names(corr_clust)[corr_clust==x]]))
tmp_cellTypes_merge <- gsub("*\\.$", "", tmp_cellTypes_merge)

tmp_cols_merge <- sapply(unique(corr_clust), function(x) Reduce(f=paste0, tmp_cols[names(list_module_genes) %in% names(corr_clust)[corr_clust==x]]))
tmp_cols_merge <- gsub("\\..*$", "", tmp_cols_merge)

names(list_module_genes_merge) <- paste0(tmp_cellTypes_merge, "__", tmp_cols_merge)
```

# Make merged module color assignment vectors (for module cell embeddings)

```{r}
# for every module, make a colors vector where the genes are coloured, within the whole range of genes in the dissTOM
scale_data_path <- dir(path = scratch_dir, pattern = paste0(data_prefix, "_scale_regr_data_ensembl"), full.names = T)
load_obj(scale_data_path) %>% t -> datExpr 

allGenes <- colnames(datExpr)
list_colors_merge <- mapply(function(x,y) ifelse(allGenes %in% x, yes=y, no="grey"), 
                                x=list_module_genes_merge, 
                                y=names(list_module_genes_merge), SIMPLIFY=F)
list_colors_merge <- lapply(list_colors_merge,as.factor)
```

### Compute eigen embedding of the merged modules on all cells
Can only do eigen embedding as otherwise we need to compute the full matrix TOM and then get the kIMs

```{r}

invisible(gc())
  
latentGeneType <- "ME" 

cl <- makeCluster(n_cores, type="FORK", outfile = paste0(log_dir, "merged_mod_cell_embed_mat.txt"))

list_cellModEmbed_mat <- clusterMap(cl, function(x,y) cellModEmbed(datExpr = datExpr, 
                                                                     colours = x,
                                                                     latentGeneType = latentGeneType,
                                                                     cellType = y,
                                                                     kMs = NULL), 
                                    x = list_colors_merge, 
                                    y = names(list_colors_merge),
                                    SIMPLIFY=F,
                                    .scheduling = c("dynamic"))

stopCluster(cl)

invisible(gc()); invisible(R.utils::gcDLLs())

list_cellModEmbed_mat %>% Reduce(function(mat1, mat2) cbind(mat1, mat2), .) -> cellModEmbed_mat

rownames(cellModEmbed_mat) <- rownames(datExpr)
  
```

# Compute rare variant and mendelian gene enrichment with the merged modules

```{r}
# TODO
```

# Compute MAGMA enrichment with the merged modules 

```{r}
# TODO
```

# 

```{r}

```

# Compute eigen_mat of the merged modules

```{r}

```


### Plot module-metadata correlation matrices

```{r}
#TODO: Incorporate into eigen plot (or simply replace with another form)
 

if (!is.null(metadata)) {
  for (cell in names(list_mod_metadata_corr_rho)){
    pdf(sprintf("%s%s_%s_mod_corr_metadata_%s.pdf", plots_dir, data_prefix, cell, flag_date), w=max(8, ncol(list_mod_metadata_corr_rho[[cell]]) %/% 2), h=max(8, nrow(list_mod_metadata_corr_rho[[cell]]) %/% 2)) # TODO: adapt this dynamically
    corrplot(corr = as.matrix(list_mod_metadata_corr_rho[[cell]]),
             add = F,
             addCoef.col = "black",
             number.digits = 2L,
             number.cex = 2,
             tl.cex = 2,
             cl.cex = 1,
             method = "color",
             col=colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu")), bias=1)(200),
             is.corr=T,
             #order = "hclust",
             #hclust.method = hclustMethod,
             title=NULL,#sprintf("%s eigenvector - metadata correlations", data_prefix),
             #addCoef.col = F,
             p.mat = t(as.matrix(list_mod_metadata_corr_fdr[[cell]])),
             sig.level = 5e-2)

    dev.off()
  }
}

```

### Plot t-SNE of cell clusters

```{r, fig.height=10, fig.width=10}
#seurat_obj <- load_obj(f=sprintf("%sseurat_obj_ensembl.RData",RObjects_dir))
seurat_obj <- load_obj(f=seurat_path)

if (is.null(seurat_obj@dr$pca)) seurat_obj <- RunPCA(object=seurat_obj, pc.genes = var.genes, pcs.compute = 20, do.print = F)
if (is.null(seurat_obj@dr$tsne)) seurat_obj <- RunTSNE(object = seurat_obj, reduction.use = PCA, dims.use = 1:20)
TSNEPlot(seurat_obj, do.label = T, label.size = 8)
#TSNEPlot(seurat_obj, colors.use = htra_colors, do.label = T)
ggsave(paste0(plots_dir,data_prefix, "_TSNE_cell_clusters_", flag_date, ".pdf"),w=12, h=10)

```

## Plot metadata in cells on t-SNE featureplots

```{r, fig.height=10, fig.width=10}

for (j in names(seurat_obj@meta.data)) seurat_obj@meta.data[j] <- NULL
seurat_obj <- AddMetaData(seurat_obj, as.data.frame(metadata))

for (feat in names(seurat_obj@meta.data)) {
  color_to_plot <- "blue4"
  FeaturePlot(seurat_obj, features.plot = feat, cols.use = c("grey85", color_to_plot))#, min.cutoff = c("q25"))
  ggsave(paste0(plots_dir,data_prefix,"_featplot_", feat, flag_date, ".pdf"),w=12, h=10)
}

```

### Plot module eigengene expression on t-SNE featureplots 

```{r, fig.height=10, fig.width=10}

for (j in names(seurat_obj@meta.data)) seurat_obj@meta.data[j] <- NULL
seurat_obj <- AddMetaData(seurat_obj, cellModEmbed_mat[match(rownames(seurat_obj@meta.data), rownames(cellModEmbed_mat)),])

for (mod in names(seurat_obj@meta.data)) {
  color_to_plot <- "blue4"
  FeaturePlot(seurat_obj, features.plot = mod, cols.use = c("grey85", color_to_plot), min.cutoff = c("q25"))
  ggsave(paste0(plots_dir,flag_date,"_",data_prefix,"_featplot_mod_", mod, ".pdf"),w=12, h=10)
}

```

